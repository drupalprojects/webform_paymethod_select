<?php
/**
 * @file
 */

use \Drupal\webform_paymethod_select\WebformPaymentContext;
use \Drupal\webform_paymethod_select\PaymentRecurrentController;
use \Drupal\little_helpers\Webform\Submission;
use \Drupal\little_helpers\Webform\FormState;
use \Drupal\little_helpers\Webform\Webform;

if (module_exists('form_builder_webform') == TRUE) {
  require_once dirname(__FILE__) . '/webform_paymethod_select.form_builder.inc';
  require_once drupal_get_path('module', 'form_builder') . '/includes/form_builder.properties.inc';
}
require_once dirname(__FILE__) . '/webform_paymethod_select.line_item.inc';
require_once dirname(__FILE__) . '/webform_paymethod_select.webform.inc';

/**
 * Implements hook_menu().
 */
function webform_paymethod_select_menu() {
  $menu['webform-payment/error/%entity_object'] = array(
    'title' => 'Payment failed or cancelled',
    'load arguments' => array('payment'),
    'page arguments' => array(2),
    'page callback' => 'webform_paymethod_select_error_page',
    'type' => MENU_CALLBACK,
    'file' => 'webform_paymethod_select.pages.inc',
    'access callback' => 'webform_paymethod_select_payment_access',
    'access arguments' => array(2),
  );
  return $menu;
}

function webform_paymethod_select_hmac(\Payment $payment) {
  return drupal_hmac_base64($payment->pid, drupal_get_hash_salt() . 'webform_paymethod_select');
}

function webform_paymethod_select_payment_access(\Payment $payment) {
  return isset($_GET['wpst']) && $_GET['wpst'] == webform_paymethod_select_hmac($payment);
}

/**
 * Implements hook_webform_component_info().
 */
function webform_paymethod_select_webform_component_info() {
  $components['paymethod_select'] = array(
    'label'       => t('Payment Selector'),
    'description' => t('Provides a selectable list of payment methods for a webform.'),
    'features'    => array(
      'default_value' => FALSE,
      'required'      => TRUE,
      'csv'           => FALSE,
    ),
    'file' => 'webform_paymethod_select.webform.inc',
  );

  return $components;
}


/**
 * Payment finish callback function specified as an argument to
 * the Payment constructor used for the paymethod_select component
 */
function webform_paymethod_select_payment_finish(Payment $payment) {
  $status = $payment->getStatus()->status;
  $context = $payment->context_data['context'];
  if (payment_status_is_or_has_ancestor($status, PAYMENT_STATUS_SUCCESS)) {
    $context->statusSuccess($payment);
  }
  elseif (payment_status_is_or_has_ancestor($status, PAYMENT_STATUS_PENDING)) {
    $context->statusPending($payment);
  }
  else {
    $context->redirectToStatus($payment);
  }
}

/**
 * Helper function to get a cleaned payment method controller name
 * this is necessary for controller names that include PHP namespaces
 */
function webform_paymethod_select_clean_name($controller_name) {
  return drupal_clean_css_identifier(
    $controller_name,
    array(
      ' ' => '-',
      '_' => '-',
      '/' => '-',
      '[' => '-',
      ']' => '',
      '\\' => '',
    )
  );
}

/**
 * Implements hook_element_info().
 */
function webform_paymethod_select_element_info() {
  // A payment method selection and configuration element. Every form this
  // element is used in should have a Payment object in $form_state['payment'].
  $elements['paymethod_select'] = array(
    '#input'            => TRUE,
    '#process'          => array('webform_paymethod_select_form_process'),
    '#element_validate' => array('webform_paymethod_select_form_process_validate'),
  );

  return $elements;
}

/**
 * helper function to preload all forms defined by the individual payment methods
 */
function _webform_paymethod_select_get_payment_method_form(&$element, &$form_state, PaymentMethod $method) {
  $form_element_name = webform_paymethod_select_clean_name($method->controller->name);

  $element['payment_method_all_forms'][$form_element_name] = array(
    '#type'        => 'fieldset',
    '#id'          => $form_element_name,
    '#title'       => t($method->title_generic),
    '#attributes'  => array('class' => array('payment-method-form')),
    '#collapsible' => FALSE,
    '#collapsed'   => FALSE,
    '#states' => array(
      'visible' => array(
        '#payment-method-selector input' => array('value' => (string) $method->pmid),
      ),
    ),
  );

  $form_elements_callback = $method->controller->payment_configuration_form_elements_callback;
  if (function_exists($form_elements_callback) == TRUE) {
    $element['payment_method_all_forms'][$form_element_name] += call_user_func($form_elements_callback, $element['payment_method_all_forms'][$form_element_name], $form_state);
  }
}

/**
 * form process function that was set in hook_element_info().
 */
function webform_paymethod_select_form_process(array $element, array &$form_state, array &$form) {

  $payment          = $form_state['payment'];
  $element['#tree'] = TRUE;
  $pmid_options     = array();

  if (!empty($element['#selected_payment_methods'])) {
    $available_payment_methods = $payment->availablePaymentMethods(entity_load('payment_method', $element['#selected_payment_methods']));
    foreach ($available_payment_methods as $payment_method) {
      $pmid_options[(int) $payment_method->pmid] = check_plain(t($payment_method->title_generic));
    }
    $node = webform_paymethod_select_get_node($form, $form_state);
    $context = new WebformPaymentContext(new FormState($node, $form, $form_state), $form_state);
    drupal_alter(
      'webform_paymethod_select_method_list',
      $context,
      $available_payment_methods,
      $pmid_options
    );
  }

  $element['#prefix'] = '<div id="paymethod-select-wrapper">';
  $element['#suffix'] = '</div>';
  $element['payment_method_all_forms'] = array(
    '#type'        => 'container',
    '#id'          => 'payment-method-all-forms',
    '#weight'      => 2,
    '#attributes'  => array('class' => array('payment-method-all-forms')),
  );

  if (!count($pmid_options)) {
    if (!$payment->pid) {
      $form['#disabled'] = TRUE;
    }
    $element['pmid_title'] = array(
      '#type'   => 'item',
      '#title'  => isset($element['#title']) ? $element['#title'] : NULL,
      '#markup' => t('There are no payment methods, check the options of this webform element to enable methods.'),
    );
  }
  else {
    reset($pmid_options);
    $payment_method_default = isset($payment->method) ? $payment->method->pmid : key($pmid_options);

    foreach ($pmid_options as $pmid => $method_name) {
      $payment->method = $available_payment_methods[$pmid];
      _webform_paymethod_select_get_payment_method_form($element, $form_state, $payment->method);
      unset($payment->method);
    }

    $element['payment_method_selector'] = array(
      '#type'          => 'radios',
      '#id'            => 'payment-method-selector',
      '#weight'        => 1,
      '#title'         => isset($element['#title']) ? $element['#title'] : NULL,
      '#options'       => $pmid_options,
      '#default_value' => $payment_method_default,
      '#required'      => $element['#required'],
      '#attributes'    => array('class' => array('paymethod-select-radios')),
      '#access'        => count($pmid_options) > 1,
    );
  }
  return $element;
}

/**
 * form validate callback that was set in hook_element_info().
 */
function webform_paymethod_select_form_process_validate(array $element, array &$form_state) {
  $payment = $form_state['payment'];
  $values  = drupal_array_get_nested_value($form_state['values'], $element['#parents']);
  $pmid    = (int) $values['payment_method_selector'];

  $payment->method = $method = entity_load_single('payment_method', $pmid);
  if ($payment->method->name === 'payment_method_unavailable') {
    throw new Exception(t('Invalid Payment Method selected.'));
  }

  $node = webform_paymethod_select_get_node();
  $context = new WebformPaymentContext(new FormState($node, $form_state['complete form'], $form_state), $form_state);
  $payment->context_data['context'] = $context;

  $method_validate_callback = $method->controller->payment_configuration_form_elements_callback . '_validate';
  if (function_exists($method_validate_callback)) {
    $selected_method = webform_paymethod_select_clean_name($method->controller->name);
    $method_element = &$element['payment_method_all_forms'][$selected_method];
    $method_validate_callback($method_element, $form_state);
  }
  $payment->context_data['context'] = NULL;
}

/**
 * Helper function to get the current node object
 */
function webform_paymethod_select_get_node(&$form = NULL, &$form_state = NULL) {
  static $node = NULL;

  if ($node == NULL) {
    if (!empty($form['#node'])) {
      $node = $form['#node'];
    }
    elseif (!empty($form['nid']['#value'])) {
      $node = node_load($form['nid']['#value']);
    }
    elseif (isset($form_state['build_info']) && $form_state['build_info']['form_id'] == 'form_builder_field_configure') {
      $node = node_load($form_state['build_info']['args'][1]);
    }
    else {
      if (($node = menu_get_object()) == NULL) {
        $get = NULL;
        if (isset($_GET['destination']) == TRUE) {
          $get = $_GET['destination'];
        }
        elseif (isset($_GET['q']) == TRUE) {
          $get = $_GET['q'];
        }
        if (   $get != NULL
            && is_numeric(($nid = preg_replace('/^.*node\/(\d+)\/.*$/', '$1', $get))) == TRUE) {
          $node = node_load($nid);
        }
      }
    }
  }
  return $node;
}

/**
 * Helper function to create and add a payment object to the form_state
 */
function _webform_paymethod_select_set_payment(&$form_state, &$component = NULL) {
  $config = $component ? $component['extra'] : array();
  $config += array(
    'line_items' => array(),
    'payment_description' => t('Default Payment'),
    'currency_code' => 'EUR',
  );

  $payment = new Payment(
    array(
      'currency_code'   => $config['currency_code'],
      'description'     => $config['payment_description'],
      'finish_callback' => 'webform_paymethod_select_payment_finish',
    )
  );

  foreach ($config['line_items'] as $line_item) {
    $payment->setLineItem($line_item);
  }
  $form_state['payment'] = $payment;
}

/**
 * Implements hook_form_alter().
 *
 * We need to ensure a payment object is set in $form_state['payment']
 * This alters the form for forms used by form_builder_webform
 */
function webform_paymethod_select_form_alter(&$form, &$form_state, $form_id) {
  if ($form_id == 'form_builder_preview' && empty($form_state['payment']) == TRUE) {
    _webform_paymethod_select_set_payment($form_state);
  }
}

/**
 * Implements hook_form_<BASE form ID>_alter().
 *
 * We need to ensure a payment object is set in $form_state['payment']
 * This alters all webforms using the paymethod_select webform component
 */
function webform_paymethod_select_form_webform_client_form_alter(&$form, &$form_state, $form_id) {
  $node = $form['#node'];
  $webform = new Webform($node);
  $components = $webform->componentsByType('paymethod_select');
  if (count($components)) {
    $component = array_pop($components);
    if (empty($form_state['payment']) == TRUE) {
      _webform_paymethod_select_set_payment($form_state, $component);
    }
    if (in_array('webform_paymethod_select_form_submit', $form['#submit']) == FALSE) {
      $form['#submit'][] = 'webform_paymethod_select_form_submit';
    }
  }
}

/**
 * form submit handler added in hook_form_webform_client_form_alter() containing
 * the paymethod_select webform component
 *
 * it's main purpose is to call the execute method of the payment object
 * (which in turn calls the execute method of the payment method controller)
 * that also saves the payment into the DB
 */
function webform_paymethod_select_form_submit($form, &$form_state) {
  if (!empty($form_state['webform_completed'])) {
    $payment = &$form_state['payment'];
    // Allow payment controllers to access the form_state.
    $payment->form_state = &$form_state;
    $node    = $form['#node'];

    $submission = Submission::load($node->nid, $form_state['values']['details']['sid']);
    $context = new WebformPaymentContext($submission, $form_state);
    $payment->context_data['context'] = $context;

    // handle setting the amount value in line items that were configured to
    // not have a fixed amount
    foreach ($payment->line_items as $line_item) {
      if ($line_item->amount_source === 'component') {
        $amount = $submission->valueByCid($line_item->amount_component);
        $amount = str_replace(',', '.', $amount);
        $line_item->amount = (float) $amount;
      }
    }
    entity_save('payment', $payment);

    // Execute the payment.
    if ($payment->getStatus()->status == PAYMENT_STATUS_NEW) {
      $payment->execute();
    }

    // Set the component value to the $payment->pid - we don't save any payment data.
    $webform = $submission->webform;
    $cids = array_keys($webform->componentsByType('paymethod_select'));
    db_query(
      "UPDATE {webform_submitted_data} SET data=:pid WHERE nid=:nid AND cid IN(:cids) AND sid=:sid",
      array(':nid' => $node->nid, ':cids' => $cids, ':sid' => $submission->sid, ':pid' => $payment->pid)
    );
  }
}

/**
 * Implements hook_webform_submission_presave().
 *
 * We don't want to save sensitive payment information.
 */
function webform_paymethod_select_webform_submission_presave($node, &$submission) {
  $webform = new Webform($node);
  foreach(array_keys($webform->componentsByType('paymethod_select')) as $cid) {
    $submission->data[$cid]['value'] = array("no payment data here");
  }
}

/**
 * Implements hook_FORM_ID_alter().
 * Implements hook_form_form_builder_field_configure_alter().
 *
 * Generate a list of all available components that might be used as amount_source
 * and make it available for @see webform_paymethod_select_element_process_line_item().
 */
function webform_paymethod_select_form_form_builder_field_configure_alter(&$form, &$form_state) {
  if ($form['#_edit_element']['#form_builder']['element_type'] != 'paymethod_select') {
    return;
  }

  $element = &$form['#_edit_element'];
  $build_info = &$form_state['build_info'];
  $other_components = NULL;
  if ($build_info['form_id'] == 'form_builder_field_configure') {
    $cache = form_builder_cache_load($build_info['args'][0], $build_info['args'][1]);
    $cache['#depth'] = -1;
    $felements[] = &$cache;
    $other_components = array();
    while (!empty($felements)) {
      $felem = array_shift($felements);
      foreach (array_reverse(element_children($felem, TRUE)) as $key) {
        $felem[$key]['#depth'] = $felem['#depth'] + 1;
        array_unshift($felements, $felem[$key]);
      }
      if (!empty($felem['#form_builder']) && $felem['#form_builder']['element_id'] != $element['#form_builder']['element_id']) {
        $other_components[$felem['#form_builder']['element_id']] = str_repeat('-', $felem['#depth']) . ' ' . $felem['#title'];
      }
    }
  }
  $form_state['payment_line_item_other_components'] = $other_components;
}

/**
 * Implements hook_node_presave().
 *
 * Transform form_builder-element_id's in ->amount_component
 * into webform component IDs.
 */
function webform_paymethod_select_node_presave($node) {
  if (!module_exists('form_builder_webform') || !isset($node->webform) || !isset($node->nid)) {
    return;
  }
  require_once drupal_get_path('module', 'form_builder') . '/includes/form_builder.cache.inc';
  if (!($cache = form_builder_cache_load('webform', $node->nid))) {
    return;
  }

  $webform = new Webform($node);
  foreach ($webform->componentsByType('paymethod_select') as $component) {
    // The items sub-array is only present if the component has been edited.
    if (!isset($component['extra']['line_items']['items'])) {
      continue;
    }
    foreach ($component['extra']['line_items']['items'] as $item) {
      if (!empty($item->amount_component) && !is_numeric($item->amount_component)) {
        if (strpos($item->amount_component, 'cid_') === 0) {
          $item->amount_component = (int) substr($item->amount_component, 4);
        }
        elseif (strpos($item->amount_component, 'new_') === 0) {
          $element = form_builder_get_element($fcache, $item->amount_component);
          $item->amount_component = $element['#webform_component']['cid'];
        }
      }
    }
  }
}

/**
 * Implements hook_form_FORM_ID_alter().
 * Implements hook_form_form_builder_webform_save_form_alter().
 */
function webform_paymethod_select_form_form_builder_webform_save_form_alter(&$form, &$form_state) {
  $form['#attached']['js'][] = 'misc/ajax.js';
  $form['#attached']['js'][] = 'misc/states.js';
}
